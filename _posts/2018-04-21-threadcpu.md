---
layout: post
title: thread-core-cpu
---

### CPU、核、线程

```
# CPU
1.CPU（中央处理器）与内存存储器（Memory）、输入/输出（I/O）设备合称为电子计算机三大核心部件；
2.CPU包括：运算器（逻辑运算）、寄存器（暂存指令、数据、地址）、控制器（指令译码）；

# CPU内核（核心）
1.CPU内核是CPU中间的核心芯片，由单晶硅制成，用来完成所有的计算、接受/存储命令、处理数据等，是数字处理核心。
2.一个核心同时只能执行一个线程。

# 进程
>  进程是操作系统进行资源（包括cpu、内存、磁盘IO等）分配的最小单位；
#线程
>  线程是CPU调度和分配的最小单位;
>  每个线程共享堆空间，拥有自己独立的栈空间;
>  是进程中的实际运行单位;

```

##### 上下文切换
```
1.CPU会给线程分配时间片（即分配给线程的时间），执行完时间后会挂起当前线程，切换并执行另一个线程；
2.CPU切换线程之前会保存当前线程的状态，该线程下个时间片执行时从该状态继续执行；
3.CPU保存A线程的状态、切换到B线程并加载B线程的状态的过程称之为：上下文切换；
（任务的状态保存及再加载, 这段过程就叫做上下文切换）

# 引起上下文切换的原因：
1.时间片用完，CPU正常调度下一个任务
2.被其他优先级更高的任务抢占
3.执行任务碰到IO阻塞，调度器挂起当前任务，切换执行下一个任务
4.用户代码主动挂起当前任务让出CPU时间
5.多任务抢占资源，由于没有抢到被挂起
6.硬件中断

```

##### 线程开销
```
1.线程创建于消亡
2.上下文切换
3.保存并维持线程的本地栈

```

##### 多核下选择线程池数量
```
1.CPU密集型运算，线程池数量参考为NCPU+1；尽量减少上下文切换带来的消耗；
2.IO密集型运算，线程池数量参考为2*NCPU；当线程阻塞时，可切换其他线程继续执行，提高CPU利用效率；

```


##### 线程常用方法
```
#### String getName()返回线程名称
#### void setName(String name) 改变线程名称
#### int getPriority() 返回线程优先级
#### void setPriority(int newPriority) 设置新的优先级
#### boolean isDaemon()测试是否为守护线程
#### void setDaemon(boolean on) 标记为守护线程

#### static void sleep(long millis) 睡眠,线程阻塞，不会释放对象锁
#### void wait()	线程挂起，释放对象锁
#### void notify()  唤醒线程
#### void interrupt() 中断线程
#### static void yield（） 暂停当前正在执行的线程对象，并执行其他线程
#### void join() 等待该线程终止

```

##### Callable和Runnable区别
```
#### 实现方法名称不一样Callable实现方法call();Runnable实现方法是run();
#### Callable任务执行后可以有返回值，Runnable不可以
#### call()可以抛出异常run()不可以
#### 运行Callable任务可以拿到一个Future对象，表示异步计算的结果

```

##### 如何停止一个正在运行的对象
```
#### 使用定义一个volatile的退出标志中止线程
#### 使用stop()方法强行终止线程（不推荐使用，易发生不可预料的结果）
#### 使用interrupt()方法中断线程

```

